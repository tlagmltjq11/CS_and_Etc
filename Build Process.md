## 빌드

![빌드](https://user-images.githubusercontent.com/43705434/130769582-ca6ab800-aa91-4dcd-9b10-f85423a11f30.PNG)<br>
<br>

컴퓨터는 근본적으로는 **0과 1**밖에 모른다.<br>
우리가 작성하는 코드들은 거의 대부분 고급언어를 사용하기 때문에<br>
결국에는 컴퓨터(CPU)가 이해할 수 있도록 번역을 해주어야한다.<br>

컴퓨터가 이해하는 언어를 기계어라고 하는데, 우리가 만든 소스 코드가 컴퓨터 입장에서는 해외판 책이 되는 것이고,<br>
이 책을 기계어(machine code)로 번역하여 컴퓨터에서 이해할 수 있는, 즉 실행 가능한 파일로 만드는 과정을 빌드(Build) 라고 한다.<br>

정리하자면 우리가 만든 소스코드를 '빌드'라는 과정을 통해 실행 파일을 얻게 되는 것이다.<br>
그 실행파일은 exe, exec 등등 여러 종류가 있다.<br>
이러한 실행파일은 기계어(Machine Code) 라고 언어(CPU가 읽을 수 있는 이진코드)로 이루어져 있다.<br>
<br>

**즉 한마디로 소스코드 파일을 실행가능한 소프트웨어 산출물로 만드는 일련의 과정을 말한다.**<br>
언어마다 다르지만 이러한 빌드에는 대게 `전처리, 컴파일, 어셈블, 링크 등` 의 과정이 포함되어 있다.<br> 
<br>
<br>

## 컴파일

![컴파일](https://user-images.githubusercontent.com/43705434/130770495-d89b1cfd-f2b2-4d37-b9e3-44766bf66a1e.PNG)<br>
<br>

**컴파일이란 개발자가 작성한 소스코드를 바이너리 코드로 변환하는 과정을 말한다.**<br>
-> c# 같은 경우 1차 컴파일 후 가상머신 CLR에서 사용할 **바이트 코드(CIL)** 가 생성된다.<br>
-> 바이트코드는 가상머신이 이해할 수 있는 중간언어라고 보면 된다.<br>
-> 기계어는 아니지만 어셈블리어처럼 '기계에 조금 더 가까운 언어'로 되어있다.<br>

**즉, 컴퓨터가 이해할 수 있는 기계어로 변환하는 작업이다.**<br>
이러한 작업을 해주는 프로그램을 가르켜 컴파일러(Compiler)라 한다.<br>
**즉 저수준(기계어 포함)의 코드로 번역하는 과정을 의미하는데, 언어마다 특징이 다르기에<br>
바로 기계어로 바뀔 수도, 중간 과정을 위한 바이트 코드로 바뀔 수도 있다.**<br>
<br>
<br>

## 링크

<img src="https://user-images.githubusercontent.com/43705434/130770499-9a3dcc5b-493b-42b7-a63b-ea33af87b8d4.PNG" width="450" height="400"><br>
<br>

프로젝트를 진행하다 보면, 소스파일이 여러개 생성되고<br>
A 소스파일에서 B 소스파일에 존재하는 함수(메서드)를 호출하는 경우가 있다.<br>
이때, A와 B를 각각 compile만 하면 A가 B에 존재하는 함수를 찾을 수 없어 호출할 수가 없다.<br>
따라서, A와 B를 **연결해주는 작업** 이 필요하다.<br>

해당 작업을 Link라고 한다.<br>
여러개로 분리된 compile한 소스파일들을 최종 실행 가능한 파일로 만들기 위해 필요한 부분을 찾아서 연결해주는 작업이다.<br>
**Link는 정적링크(static link)와 동적링크(dynamic link)가 있다.**<br>

* 정적링크라이브러리(Static Link Library) - .lib<br>
**컴파일 시에 라이브러리가 실행파일에 연결된다.**<br>
실행 파일에 함수의 코드가 복사되기 때문에 실행파일의 **크기가 커지는 단점**이 있지만 실행 파일은 완전한 단독 실행 파일이 된다.<br>
실행파일에 함수의 코드가 포함되어 있기 때문에 컴파일이 끝나면 lib 파일이 없어도 프로그램을 실행 할 수있다.<br>
<br>

* 동적링크라이브러리(Dynamic Link Library) - .dll<br>
정적라이브러리처럼 컴파일 시에 함수가 연결되는 방식이 아닌 **런타임시에 라이브러리가 실행파일에 연결된다.**<br>
실행파일에는 호출할 라이브러리의 정보만 포함되고 실제 함수 **코드는 복사**되지 않으므로 실행 **파일의 크기가 작아진다.**<br>
하지만 실행 파일은 함수에 대한 정보만 가지고 있을 뿐 실제 코드를 가지고 있지 않기 때문에<br>
프로그램 실행시에는 **dll 파일이 항상 존재해야 한다.**<br>

자바의 경우 JVM이 프로그램 실행 도중 필요한 클래스를 찾아서 클래스 패스에 로드해주는데 이것이 동적링크의 예이다.<br>
<br>
<br>

## 플랫폼 의존적

<img src="https://user-images.githubusercontent.com/43705434/130770505-ba6bd91c-5285-4e15-aa93-9ea81f6102a8.PNG" width="550" height="250"><br>
<br>

플랫폼에 의존적이라는 말은 가장 쉽게 이해하자면 **윈도우 실행파일을 맥OS 에서 실행하지 못하는 상황을 생각하면 된다.**<br>
크게 두 가지 원인이 있는데, 먼저 **어셈블리어의 경우 CPU 명령어 세트에 1대1로 매칭된다**.<br>
즉, **CPU에 의존적**이라는 것인데 **CPU 명령 체계가 거의 비슷하긴 하나 완전히 같지는 않기 때문에** CPU가 다른 경우<br>
실행하지 못하는 상황이 발생할 수 있다.<br>

그리고 다음으로는 CPU가 이해할 수 있게 번역하여 최종 실행파일로 만들기 위해 우리는 링크라는 작업을 해주었다.<br>
이 과정에서 OS 마다 서로 다른 라이브러리가 있어 링커는 해당 OS에서 요구하는 라이브러리를 연결하게 된다.<br>
**즉 OS마다 지원하는 라이브러리가 다르기 때문에 실행할 수 없는 상황이 발생할 수 있는 것이다.**<br>

우리가 프로그램을 내려받을 때 윈도우용, 맥용, 64비트, 32비트 등 이렇게 각 버전에 맞는 프로그램을<br>
설치하는 이유가 이러한 것 때문이라고 보면 된다. (또한 운영체제별로 지원하는 것도 조금씩 다르다.)<br>
<br>
<br>

## 플랫폼 독립적<br>
예전의 C, C++의 경우 개별 환경이 프로그램의 실행 시간에 영향을 미치는 문제가 있었다.<br>
하지만 Java가 나오면서 컴파일된 바이트코드는 윈도우, 리눅스, 그 어떤 실행환경이든<br>
JVM만 실행 가능하다면 실행할 수 있다는 장점을 통해 인기를 끌었고,<br>
마이크로소프트는 이를 이용해 기존 문제를 해결할 수 있도록 .NET 환경에 가상 머신을 만들어서<br>
.NET 환경의 언어로 개발된 IL(Intermediate Language, 중간 언어) 코드들은<br>
.NET Framework가 설치된 **어떠한 환경에서도 실행할 수 있도록 하였다.**<br>
대표적인 예시로 VB .NET, C#이 있다.<br>

**즉 VM(가상머신)이라는 개념을 도입해 플랫폼에 독립적인 실행환경을 구축했다는 의미이다.**<br>

<img src="https://user-images.githubusercontent.com/43705434/130770507-be9ea2aa-f07e-413f-bd8a-9e143d8e0d04.PNG" width="550" height="250"><br>
<br>

그렇다면 가상머신이란 무엇일까?<br>
VM 은 가상머신(Virtual Machine)의 줄임말인데, 쉽게 생각해서 가상 컴퓨터라고 보면 된다.<br>
**현재 컴퓨터 안에 또다른 컴퓨터 환경을 구현했다고 생각하면 이해가 좀 더 편할 수도 있을 것이다.**<br>
바이트 코드는 이 가상머신이 이해할 수 있는 코드로 되어있고, 그 가상머신 안에는 인터프리터 같은 해석기가 있어<br>
이들이 바이트코드를 해석하여 각 OS에 맞게 명령어를 해석하고 작동하는 하나의 프로그램이라고 보면 된다.<br>
쉽게 자바로 예로 들자면, 자바 소스코드를 컴파일 하면 .class 파일이 나온다.<br>
이 파일만 있으면 JVM이 설치된 어느 컴퓨터에서든 실행 할 수 있을 뿐만 아니라 거의 동일한 결과를 내보일 수 있다.<br> 

가장 대표적인 VM은 Java Virtual Machine 인 JVM 이 있다. 또한 C#의 경우는 .NET의 CLR 이 있다.<br>
즉, VM을 통해 **'플랫폼에 독립적'** 인 장점을 갖고왔고, 초기 컴파일 단계를 통해 바이트코드로 기계어에<br>
**더 가까운 언어로 번역을 한 번 해놓았기 때문에 속도도 기존 인터프리터 언어에 비해 더 빠르다는 장점 또한 갖고오게 되었다.**<br>

**즉, 우리가 굳이 운영체제를 신경쓰면서 각 운영체제별로 조금씩 다른 코드를 짤 필요 없이** 그냥 작성을 하고<br>
VM이 이해할 수 있는 저수준의 언어로 만들기 위해 컴파일을 해주고 이제 VM에 실행을 해주면 알아서 링킹 작업,<br>
메소드 영역 등 VM이 알아서 어떤 운영체제건 상관없이 일관 된 결과를 얻을 수 있다.<br>
**즉, VM은 또 하나의 운영체제라고 생각하고, VM이 이해 할 수 있는 언어로 변환하기 위해 우리는 컴파일을 했으며<br>
VM에서 해당 파일을 실행만 해주면 VM은 설치 된 운영체제와 인터프리터 형식으로 매번 주고 받으며 실행을 알아서 해주는<br>
일종의 기계(프로그램)라고 보면 이해가 좀 더 편할 것이다.**<br>
<br>
<br>

## C언어 빌드 과정

![c언어빌드과정](https://user-images.githubusercontent.com/43705434/130769594-e6e14a84-20a5-495c-b5ec-dd2b31f7025b.PNG)<br>
<br>

1. 전처리 (Preprocess)<br>
컴파일러가 쉽게 인식할 수 있도록 소스 코드 내부에 "#"으로 시작되는 명령어 재정리<br>
(#define MAX 100이라고 선언했을 경우, 소스에서 MAX라고 쓰여있는 부분을 100으로 치환)<br>
**#include 란 해당 파일을 선언한 파일에 그대로 넣어주는 역할이다.<br>
-> 추후 링킹과정에서 실제 라이브러리와 연결이 될 것 이다.**<br>
hello.c 파일을 입력으로 hello.i 파일 생성<br>

2. 컴파일 (Compile)<br>
전처리된 소스 코드를 어셈블리어로 변환<br>
hello.i 파일을 입력으로 hello.s 파일 생성<br> 

3. 어셈블 (Assemble)<br>
어셈블리어를 기계어(binary)로 변환<br>
hello.s 파일을 입력으로 hello.o 파일 생성<br>

![어셈블리어](https://user-images.githubusercontent.com/43705434/130769590-2eefbddb-1e91-4ea7-aace-3ce896c460af.PNG)<br>

4. 링커 (Linker)<br>
목적 파일을 관련된 라이브러리와 연결하여 실행 파일 생성<br>
hello.o 파일을 입력으로 hello.exe 파일 생성<br>
<br>

※ 링킹이 필요한 이유<br>
어셈블(Assemble) 과정을 마친 후 얻은 목적 파일은 직접 실행할 수 없는 파일이다.<br>
표준 라이브러리 및 사용자 라이브러리를 포함하고 있지 않기 때문이다.<br>
링킹을 통해 필요한 라이브러리를 목적 파일과 연결하는 과정이 끝나면 실행 가능한 exe파일이 생성된다.<br>
<br>
<br>

## C# 빌드(실행) 과정
<img src="https://user-images.githubusercontent.com/43705434/130810569-277dc1c3-8627-4d71-9bbb-4096d441bc47.PNG" width="550" height="450"><br>
<br>

닷넷기반 언어(C#,VB.NET 등)로 작성한 프로그램의 실행 과정을 살펴 본다.<br>
<br>
<br>

<img src="https://user-images.githubusercontent.com/43705434/130810547-deadf277-dd4b-4eb7-9033-e04b74d19e61.PNG" width="550" height="450"><br>
<br>

[1] C# 컴파일러가 소스코드를 **컴파일 한다.**<br>
csc.exe 라는 C# 컴파일러가 동작한다.<br>
이렇게 컴파일 되어 파생되는 **결과 파일은 exe 또는 dll 파일이 되며, 이를 어셈블리라고 부른다.**<br>
단, 닷넷에서는 자바의 중간 바이트 코드와 유사하게 **CIL 이라는 중간언어로 컴파일 된다.**<br>
즉, 바로 실행가능한 파일이 아니라는 말이다. 자바의 플랫폼 독립성을 위해 중간 바이트 코드가 필요 했듯<br>
닷넷에서도 **플랫폼 독립성과 언어 통합을 위해 중간단계를 거치게 되는 것이다.**<br>
**참고로 언어 통합이란 닷넷의 장점 중에 하나인데 C# 코드이든, VB.NET 코드이든 소스코드는 달라도<br>
컴파일 되어 파생되는 중간언어(IL코드)는 완전히 동일하게 된다.<br>
이 결과로 각기 다른 언어로 작성한 닷넷 소스라 할 지라도 상호 작용이 가능하게 되는 것이다.**<br>
또한 이 exe (or dll) 파일에는 소스 코드내의 **클래스를 설명하는 메타 데이터와 매니페스트** 정보가 포함된다.<br>

**CIL을 거쳐야하는 이유**<br>
**즉 1차적으로 CIL로 변환할 때 모든.NET 환경의 언어가 동일하게 변환되기 때문에 언어 간 통합이 가능해지고,<br> 
해당 CIL을 CLR이 플랫폼에 맞춰 최적화하며 Jit 컴파일러를 실행시켜 현재 플랫폼에 맞는 기계어로 최종변환을 하기 때문에<br> 
중간단계인 CIL를 한번 거쳐야 한다는 것이다. -> 플랫폼에 독립적으로 실행이 가능해지는 것이다.**<br>
<br>
<br>

[2] 1번에서 만들어진 중간언어는 **실제 실행 시** 실행단계로 넘어 간다.<br>
<br>
<br>

<img src="https://user-images.githubusercontent.com/43705434/130810551-881546f0-b637-4464-bc88-5f988c1dc1d0.PNG" width="550" height="450"><br>
<br>

[3] 이제 부터 그 유명한 **CLR 의 영역이다.**<br>
CLR 은 1번에서 컴파일된 중간코드를 실제로 실행시키기 위한 각종 서비스들의 모음이라 할 수 있다.<br>
다시 말해 닷넷으로 만든 프로그램의 실행환경을 제공하는 것이다.<br>
실행을 위해 IL 코드가 CLR로 호스트 될때 제일 처음 CLR 내부의 Class Loader 에 의해 클래스들의 레이아웃 로드와<br>
메타데이타를 로드하고 중간 여러 과정을 거쳐 **메모리에 로드한다.**<br>
<br>
<br>

[4] **메모리에 올라간 어셈블리는 실행되는 플랫폼이 이해 할 수 있는 명령어(Native Code),<br>
즉 플랫폼 종속적인 원시 코드로 컴파일 되는데 , 이때 JIT 라는 컴파일러가 관여 한다.**<br>
**JIT 컴파일 방식**은 jitter(지터)라는 애칭을 가진 컴파일러로써 **IL 코드를 특정 플랫폼 기반의 원시코드로 컴파일을 해준다.**<br>
jitter 에 의해 컴파일된 Native Code 는 다음번 사용을 위해(재사용) 메모리에 캐싱된다.<br>
따라서 동일한 어셈블리를 실행할때 또 다시 컴파일 하는 단계를 줄임으로써 실행속도의 향상을 꽤 한다.<br>
즉, 다음번 실행시에는 CIL 의 컴파일 단계가 생략 된다.<br>
**C#에서 성능 테스트를 위해 코드를 반복 수행할 때 첫 수행이 아주 느리고,<br>
다음 수행부터 비슷하게 빠른 현상을 발견할 수 있는데, 이것은 바로 JIT 컴파일 때문이다.**<br>
<br>
<br>

[5] 이제서야 우리는 우리가 작성한 프로그램을 모니터를 통해 눈으로 확인 할 수 있게 되었다.<br>
<br>
<br>

위 과정에서 눈여겨 보아야 할 것은 **컴파일이 2번이나 된다는 것이다.**<br> 
CLR은 C#뿐만 아니라 다른언어도 지원하도록 설계되어 있다.<br> 
**IL이 서로 다른언어를 이어주는 역할**을 하고,<br>
CLR이 설치된 플랫폼에서 최적화하여 컴파일한 후 **플랫폼 독립적**으로 실행되는 것이다.<br>
<br>
<br>

**자세한 과정 이미지**<br>
<img src="https://user-images.githubusercontent.com/43705434/130810574-f29f2b71-0c1a-4fd8-a865-dc373229abda.PNG" width="500" height="450"><br>
<br>
<br>
<br>

**개념정리**<br>

**CLR의 동작원리**<br>

<img src="https://user-images.githubusercontent.com/43705434/130810546-22d73b43-b0e3-467a-a571-7442d1147d68.PNG" width="400" height="400"><br>
<br>

우리가 Source code를 작성하면 C# Compiler(Language Compiler)가<br>
IL(Intermediate Language)이라는 중간 언어로 작성된 실행 파일을 만들어 준다.<br>
마지막으로 사용자가 이 파일을 실행하게 되면 CLR이 IL을 읽어<br>
하드웨어가 이해할 수 있는 NativeCode로 컴파일(JIT Compiler 이용)한 후 실행시킨다.<br>
**이러한 방식의 장점은 바로 플랫폼에 최적화된 코드를 만들어 낸다는 것이다.**<br>
단점으로는 실행 시에 이루어지는 **컴파일 비용의 부담**이다.<br>
허나 내가 만든 프로그램이 컴파일 비용의 부담없이 어떠한 기계에서도<br>
평균의 성능을 내는 것과 컴파일 비용이 조금 부담스럽긴 해도 기계에 최적화되어<br>
최고의 성능을 내는 것, 어느 쪽이 더 나은가 보면 보통 **어떠한 기계에서도 사용하는 것이 가장 좋을 것이다.**<br>
<br>
<br>

**CIL**(Common Intermidiate Language, 공통 중간 언어)<br>
**.NET 환경의 언어로 작성된 소스 코드를 컴파일했을 때 만들어지는 바이트코드** 를 의미하며, **어셈블리 코드의 일종**이다.<br>
.NET 환경의 언어로 개발할 때, 소스코드를 컴파일하게 되면 컴파일 타임에 해당 언어의 컴파일러에 의해 우선 바이트코드인 CIL Code를 생성한다.<br>
그리고 **CLR은 런타임에 JIT(Just-In-Time) 또는 AOT(Ahead-Of-Time) 컴파일 방식을 이용하여 CIL Code를 OS가 이해할 수 있는<br>
Native Code 로 변환하게 된다.**<br>
<br>
<br>

**JIT 컴파일** (CLR이 아니라 운영체제에 존재하는 것임.)<br>
JIT : Just-In-Time<br>
그렇다면 JIT 컴파일이란 무엇일까?<br>
우선, C/C++로 작성된 프로그램은 다른 언어에 비해 빠르다고 알려져 있다.<br>
왜냐하면 C/C++은 **정적인 네이티브 코드(.exe, .dll)를 생성**해 배포하기 때문이다.<br>
**반면에 Java, C#과 같은 언어들은 컴파일러가 생성한 IL 코드를 생성하여 갖고 있다가<br>
프로그램을 실행시키면 런타임에 가상머신을 통해 동적으로 네이티브 코드를 생성하게 되는데,**<br>
이 때 가상머신에 의한 **런타임 컴파일 방식을 JIT 컴파일**이라고 한다.<br>
JIT 컴파일 방식 덕분에, 개발자는 프로그램의 **실행 환경을 고려하지 않고 개발할 수 있다는 장점**이 있다.<br>
하지만 JIT 컴파일 방식은 메모리를 많이 사용하고 속도도 떨어진다는 단점이 있다.<br>
<br>
<br>

**AOT 컴파일**<br>
AOT : Ahead-Of-Time<br>
**JIT 컴파일 방식의 느린 속도를 해결하기 위해 만들어진 컴파일 방식.**<br>
**컴파일 타임**에 중간 코드를 실행 환경에 적합한 **Native Code로 컴파일을 모두 완료한다.**<br>
CIL Code를 C++ 컴파일러를 통해 .NET Native 이진코드로 변환하게 된다.<br>
.NET Native는 C++와 유사하지만, C++처럼 Unmanaged는 아니다.<br>
C++는 CRT.dll(C 런타임)을 사용하는 데 비해,<br>
.NET Native는 MRT.dll(최소 CLR 런타임)을 사용하며 여기에 GC 코드가 포함되어 있다.<br>
단 미리 번역해둔 파일을 저장하기 때문에 용량이 커지고 설치속도가 느려질 수 있다.
또한 컴파일 타임에 결정 될 수 없는 제네릭 같은 부분은 제약 사항이 존재한다고 한다.
<br>
<br>

**유니티에서 빌드 시 컴파일 방식 선택 옵션**<br>
<img src="https://user-images.githubusercontent.com/43705434/130810538-e4c6888c-de24-48ec-a21e-1d1bcd4a3143.PNG" width="450" height="400"><br>
<br>
<br>

**.NET Framework**<br>
= FCL(Framework Class Library) + CLR<br>
FCL은 .NET Framework를 대상으로 하는 모든 언어가 사용할 수 있는 **공용 클래스 라이브러리,**<br>
CLR은 공통 언어 런타임 클래스이며, **보안, 메모리, 스레드 관리, JIT 컴파일**을 수행하는 가상 머신이다.<br>
**즉, MS사에서 제공하는 윈도우 프로그램 개발 및 실행환경(FrameWork)을 의미한다.**<br>
-> 그렇다고 윈도우에서만 동작하는것이 아님, **자마린을 통해 크로스 플랫폼을 운영하고 있음.**<br>
-> **정확히는 모노 닷넷이 크로스 플랫폼이 가능한 것이라고 한다.<br>
-> 유니티는 멀티 플랫폼을 지원하는 게임 엔진이고, 이를 위한 개발환경이 필요했기에 모노 닷넷을 개발환경으로 선택한 것.<br>
-> 따라서 유니티를 사용하는 개발자들은 원래 C# 이라는 언어가 가진 제한사항 (윈도우에서만 실행가능 한 점)을 벗어나<br>
-> 여러 플랫폼에서도 실행가능 한 게임을 제작할 수 있는 것이다.**<br>
<br>
<br>

C언어가 (상대적으로) 빠른 이유<br>
컴파일을 완료하면 정적인(특정 환경에서 실행 가능한) 네이티브 코드를 생성한다.<br>
이를 실행하면 JIT 컴파일 과정 거칠 것 없이 바로 실행되므로 빠르다.<br>
<br>

Java와 C#이 (상대적으로) 느린 이유<br>
컴파일을 완료하면 IL(중간 언어) 코드인 .class, CIL 코드를 생성하고, 이를 바이너리에 포함시킨다.<br>
각각 JVM과 CLR이 런타임에 JIT 컴파일을 통해 Native Code를 생성하는 과정을 거쳐야 하므로 느리다.<br>
<br>

**컴파일 과정 간략 정리**<br>
(c) : Compile Time<br>
(r) : Runtime<br>
Source Code -> 컴파일(c) -> CIL Code -> JIT 컴파일(r) -> Native Code<br>
Source Code -> 컴파일(c) -> CIL Code -> AOT 컴파일(c) -> .NET Native Code<br>
<br>
<br>

## 참조링크
https://st-lab.tistory.com/176 <br>
https://freezboi.tistory.com/39 <br>
https://ssinyoung.tistory.com/2 <br>
https://rito15.github.io/posts/cs-dotnet-compile/ <br>
https://intra97.tistory.com/44 <br>
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=zzol3&logNo=221389699509 <br>
