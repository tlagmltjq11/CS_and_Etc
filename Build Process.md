## 빌드

![빌드](https://user-images.githubusercontent.com/43705434/130769582-ca6ab800-aa91-4dcd-9b10-f85423a11f30.PNG)<br>
<br>

컴퓨터는 근본적으로는 **0과 1**밖에 모른다.<br>
우리가 작성하는 코드들은 거의 대부분 고급언어를 사용하기 때문에<br>
결국에는 컴퓨터(CPU)가 이해할 수 있도록 번역을 해주어야한다.<br>

컴퓨터가 이해하는 언어를 기계어라고 하는데, 우리가 만든 소스 코드가 컴퓨터 입장에서는 해외판 책이 되는 것이고,<br>
이 책을 기계어(machine code)로 번역하여 컴퓨터에서 이해할 수 있는, 즉 실행 가능한 파일로 만드는 과정을 빌드(Build) 라고 한다.<br>

정리하자면 우리가 만든 소스코드를 '빌드'라는 과정을 통해 실행 파일을 얻게 되는 것이다.<br>
그 실행파일은 exe, exec 등등 여러 종류가 있다.<br>
이러한 실행파일은 기계어(Machine Code) 라고 언어(CPU가 읽을 수 있는 이진코드)로 이루어져 있다.<br>
<br>

**즉 한마디로 소스코드 파일을 실행가능한 소프트웨어 산출물로 만드는 일련의 과정을 말한다.**<br>
언어마다 다르지만 이러한 빌드에는 대게 `전처리, 컴파일, 어셈블, 링크 등` 의 과정이 포함되어 있다.<br> 
<br>
<br>

## 컴파일

![컴파일](https://user-images.githubusercontent.com/43705434/130770495-d89b1cfd-f2b2-4d37-b9e3-44766bf66a1e.PNG)<br>
<br>

**컴파일이란 개발자가 작성한 소스코드를 바이너리 코드로 변환하는 과정을 말한다.**<br>
-> c# 같은 경우 1차 컴파일 후 가상머신 CLR에서 사용할 **바이트 코드(CIL)** 가 생성된다.<br>
-> 바이트코드는 가상머신이 이해할 수 있는 중간언어라고 보면 된다.<br>
-> 기계어는 아니지만 어셈블리어처럼 '기계에 조금 더 가까운 언어'로 되어있다.<br>
-> 바이트코드로 1차적으로 컴파일하는 이유는 인터프리터 받식의 단점인 실행 속도 때문이고<br>
-> 가상머신이 비교적 빠르게 인터프리트하기 위함이다.<br>

**즉, 컴퓨터가 이해할 수 있는 기계어로 변환하는 작업이다.**<br>
이러한 작업을 해주는 프로그램을 가르켜 컴파일러(Compiler)라 한다.<br>
**즉 저수준(기계어 포함)의 코드로 번역하는 과정을 의미하는데, 언어마다 특징이 다르기에<br>
바로 기계어로 바뀔 수도, 중간 과정을 위한 바이트 코드로 바뀔 수도 있다.**<br>
<br>
<br>

## 링크

![링크사진](https://user-images.githubusercontent.com/43705434/130770499-9a3dcc5b-493b-42b7-a63b-ea33af87b8d4.PNG)<br>
<br>

프로젝트를 진행하다 보면, 소스파일이 여러개 생성되고<br>
A 소스파일에서 B 소스파일에 존재하는 함수(메서드)를 호출하는 경우가 있다.<br>
이때, A와 B를 각각 compile만 하면 A가 B에 존재하는 함수를 찾을 수 없어 호출할 수가 없다.<br>
따라서, A와 B를 **연결해주는 작업** 이 필요하다.<br>

해당 작업을 Link라고 한다.<br>
여러개로 분리된 compile한 소스파일들을 최종 실행 가능한 파일로 만들기 위해 필요한 부분을 찾아서 연결해주는 작업이다.<br>
**Link는 정적링크(static link)와 동적링크(dynamic link)가 있다.**<br>

* 정적링크라이브러리(Static Link Library) - .lib<br>
**컴파일 시에 라이브러리가 실행파일에 연결된다.**<br>
실행 파일에 함수의 코드가 복사되기 때문에 실행파일의 **크기가 커지는 단점**이 있지만 실행 파일은 완전한 단독 실행 파일이 된다.<br>
실행파일에 함수의 코드가 포함되어 있기 때문에 컴파일이 끝나면 lib 파일이 없어도 프로그램을 실행 할 수있다.<br>
<br>

* 동적링크라이브러리(Dynamic Link Library) - .dll<br>
정적라이브러리처럼 컴파일 시에 함수가 연결되는 방식이 아닌 **런타임시에 라이브러리가 실행파일에 연결된다.**<br>
실행파일에는 호출할 라이브러리의 정보만 포함되고 실제 함수 **코드는 복사**되지 않으므로 실행 **파일의 크기가 작아진다.**<br>
하지만 실행 파일은 함수에 대한 정보만 가지고 있을 뿐 실제 코드를 가지고 있지 않기 때문에<br>
프로그램 실행시에는 **dll 파일이 항상 존재해야 한다.**<br>

자바의 경우 JVM이 프로그램 실행 도중 필요한 클래스를 찾아서 클래스 패스에 로드해주는데 이것이 동적링크의 예이다.<br>
<br>
<br>

## 플랫폼 의존적

![플랫폼의존](https://user-images.githubusercontent.com/43705434/130770505-ba6bd91c-5285-4e15-aa93-9ea81f6102a8.PNG)<br>
<br>

플랫폼에 의존적이라는 말은 가장 쉽게 이해하자면 **윈도우 실행파일을 맥OS 에서 실행하지 못하는 상황을 생각하면 된다.**<br>
크게 두 가지 원인이 있는데, 먼저 **어셈블리어의 경우 CPU 명령어 세트에 1대1로 매칭된다**.<br>
즉, **CPU에 의존적**이라는 것인데 **CPU 명령 체계가 거의 비슷하긴 하나 완전히 같지는 않기 때문에** CPU가 다른 경우<br>
실행하지 못하는 상황이 발생할 수 있다.<br>

그리고 다음으로는 CPU가 이해할 수 있게 번역하여 최종 실행파일로 만들기 위해 우리는 링크라는 작업을 해주었다.<br>
이 과정에서 OS 마다 서로 다른 라이브러리가 있어 링커는 해당 OS에서 요구하는 라이브러리를 연결하게 된다.<br>
**즉 OS마다 지원하는 라이브러리가 다르기 때문에 실행할 수 없는 상황이 발생할 수 있는 것이다.**<br>

우리가 프로그램을 내려받을 때 윈도우용, 맥용, 64비트, 32비트 등 이렇게 각 버전에 맞는 프로그램을<br>
설치하는 이유가 이러한 것 때문이라고 보면 된다. (또한 운영체제별로 지원하는 것도 조금씩 다르다.)<br>
<br>

## 플랫폼 독립적<br>
예전의 C, C++의 경우 개별 환경이 프로그램의 실행 시간에 영향을 미치는 문제가 있었다.<br>
하지만 Java가 나오면서 컴파일된 바이트코드는 윈도우, 리눅스, 그 어떤 실행환경이든<br>
JVM만 실행 가능하다면 실행할 수 있다는 장점을 통해 인기를 끌었고,<br>
마이크로소프트는 이를 이용해 기존 문제를 해결할 수 있도록 .NET 환경에 가상 머신을 만들어서<br>
.NET 환경의 언어로 개발된 IL(Intermediate Language, 중간 언어) 코드들은<br>
.NET Framework가 설치된 **어떠한 환경에서도 실행할 수 있도록 하였다.**<br>
대표적인 예시로 VB .NET, C#이 있다.<br>

**즉 VM(가상머신)이라는 개념을 도입해 플랫폼에 독립적인 실행환경을 구축했다는 의미이다.**<br>

![가상머신](https://user-images.githubusercontent.com/43705434/130770507-be9ea2aa-f07e-413f-bd8a-9e143d8e0d04.PNG)<br>
<br>

그렇다면 가상머신이란 무엇일까?<br>
VM 은 가상머신(Virtual Machine)의 줄임말인데, 쉽게 생각해서 가상 컴퓨터라고 보면 된다.<br>
**현재 컴퓨터 안에 또다른 컴퓨터 환경을 구현했다고 생각하면 이해가 좀 더 편할 수도 있을 것이다.**<br>
바이트 코드는 이 가상머신이 이해할 수 있는 코드로 되어있고, 그 가상머신 안에는 인터프리터 같은 해석기가 있어<br>
이들이 바이트코드를 해석하여 각 OS에 맞게 명령어를 해석하고 작동하는 하나의 프로그램이라고 보면 된다.<br>
쉽게 자바로 예로 들자면, 자바 소스코드를 컴파일 하면 .class 파일이 나온다.<br>
이 파일만 있으면 JVM이 설치된 어느 컴퓨터에서든 실행 할 수 있을 뿐만 아니라 거의 동일한 결과를 내보일 수 있다.<br> 

가장 대표적인 VM은 Java Virtual Machine 인 JVM 이 있다. 또한 C#의 경우는 .NET의 CLR 이 있다.<br>
즉, VM을 통해 **'플랫폼에 독립적'** 인 장점을 갖고왔고, 초기 컴파일 단계를 통해 바이트코드로 기계어에<br>
더 가까운 언어로 번역을 한 번 해놓았기 때문에 속도도 기존 인터프리터 언어에 비해 더 빠르다는 장점 또한 갖고오게 되었다.<br>

**즉, 우리가 굳이 운영체제를 신경쓰면서 각 운영체제별로 조금씩 다른 코드를 짤 필요 없이** 그냥 작성을 하고<br>
VM이 이해할 수 있는 저수준의 언어로 만들기 위해 컴파일을 해주고 이제 VM에 실행을 해주면 알아서 링킹 작업,<br>
메소드 영역 등 VM이 알아서 어떤 운영체제건 상관없이 일관 된 결과를 얻을 수 있다.<br>
**즉, VM은 또 하나의 운영체제라고 생각하고, VM이 이해 할 수 있는 언어로 변환하기 위해 우리는 컴파일을 했으며<br>
VM에서 해당 파일을 실행만 해주면 VM은 설치 된 운영체제와 인터프리터 형식으로 매번 주고 받으며 실행을 알아서 해주는<br>
일종의 기계(프로그램)라고 보면 이해가 좀 더 편할 것이다.**<br>
<br>
<br>

## C언어 빌드 과정

![c언어빌드과정](https://user-images.githubusercontent.com/43705434/130769594-e6e14a84-20a5-495c-b5ec-dd2b31f7025b.PNG)<br>
<br>

1. 전처리 (Preprocess)<br>
컴파일러가 쉽게 인식할 수 있도록 소스 코드 내부에 "#"으로 시작되는 명령어 재정리<br>
(#define MAX 100이라고 선언했을 경우, 소스에서 MAX라고 쓰여있는 부분을 100으로 치환)<br>
**#include 란 해당 파일을 선언한 파일에 그대로 넣어주는 역할이다.<br>
-> 추후 링킹과정에서 실제 라이브러리와 연결이 될 것 이다.**<br>
hello.c 파일을 입력으로 hello.i 파일 생성<br>

2. 컴파일 (Compile)<br>
전처리된 소스 코드를 어셈블리어로 변환<br>
hello.i 파일을 입력으로 hello.s 파일 생성<br> 

3. 어셈블 (Assemble)<br>
어셈블리어를 기계어(binary)로 변환<br>
hello.s 파일을 입력으로 hello.o 파일 생성<br>

![어셈블리어](https://user-images.githubusercontent.com/43705434/130769590-2eefbddb-1e91-4ea7-aace-3ce896c460af.PNG)<br>

4. 링커 (Linker)<br>
목적 파일을 관련된 라이브러리와 연결하여 실행 파일 생성<br>
hello.o 파일을 입력으로 hello.exe 파일 생성<br>
<br>

※ 링킹이 필요한 이유<br>
어셈블(Assemble) 과정을 마친 후 얻은 목적 파일은 직접 실행할 수 없는 파일이다.<br>
표준 라이브러리 및 사용자 라이브러리를 포함하고 있지 않기 때문이다.<br>
링킹을 통해 필요한 라이브러리를 목적 파일과 연결하는 과정이 끝나면 실행 가능한 exe파일이 생성된다.<br>
<br>
<br>

## C# 빌드 과정
-> c# 같은 경우 1차 컴파일 후 가상머신 CLR에서 사용할 **바이트 코드(CIL)** 가 생성된다.<br>
-> 바이트코드는 가상머신이 이해할 수 있는 중간언어라고 보면 된다.<br>
-> 기계어는 아니지만 어셈블리어처럼 '기계에 조금 더 가까운 언어'로 되어있다.<br>
-> 바이트코드로 1차적으로 컴파일하는 이유는 인터프리터 받식의 단점인 실행 속도 때문이고<br>
-> 가상머신이 비교적 빠르게 인터프리트하기 위함이다.<br>


## 참조링크
https://st-lab.tistory.com/176 <br>
https://freezboi.tistory.com/39 <br>
https://ssinyoung.tistory.com/2 <br>
