## 🔔 Binding
프로그래밍에서는 **어떤 구성요소의 성격이나 값을 확정하는 것이라고 해석한다.** ⭐<br>
주로 변수의 자료형, 호출될 함수가 결정되는 과정으로 해석할 수 있다.<br>
<br>

![바인딩](https://user-images.githubusercontent.com/43705434/133895263-df33a305-cd37-4114-917e-0982e22ef982.PNG)<br>
<br>

**함수의 바인딩**<br>
함수를 만들어 컴파일을 하면, 각각의 코드가 메모리 Code 영역에 저장된다.<br>
**그리고 함수를 호출하는 부분에는 그 함수가 저장된 메모리 번지 즉, 주소값이 저장된다.**<br>

프로그램 실행 → 함수 호출 → 함수가 저장된 주소로 점프 → 함수 실행 → 원래 위치로<br>
<br>

⭐ **위 과정에서 함수를 호출하는 부분에 함수가 위치한 메모리 번지로 연결시켜주는 것을 바인딩이라고 한다.<br>
쉽게 말해, 함수의 호출부와 정의부를 연결시켜주는 것이 바인딩이라고 할 수 있다.** ⭐<br>
<br>
<br>

**함수를 바인딩하는 2가지 방법**<br>
👉 정적 바인딩 (일반 함수)<br>
컴파일 시간에 호출될 함수로 점프할 주소가 결정되어 바인딩 되는 것.<br>

👉 동적 바인딩 (가상 함수)<br>
실행 파일을 만들 때 바인딩 되지 않고 보류 상태로 둔다.<br>
점프할 메모리 번지를 저장하기 위한 메모리 공간(4 byte)을 가지고 있다가 런타임에 결정.<br>
=> 단점 : 타입 체킹으로 인한 수행 속도 저하 / 메모리 공간 낭비<br>
**virtual 키워드를 통해 동적 바인딩하는 함수를 가상 함수라고 한다.**<br>
<br>

👉 단점이 있음에도 불구하고 동적 바인딩을 하는 이유?<br>
- **재정의된 함수의 호출이 가능하기 때문이다.**<br>
https://see-ro-e.tistory.com/136?category=782427 <br>
⭐ **해당 링크에서 재정의된 가상함수가 어떻게 바인딩 되는지 확인.** ⭐<br>
<br>
<br>

**요약**<br>
**변수 바인딩 측면**<br>
👉 정적 바인딩 : 컴파일 시에 메모리를 할당한다.<br>
-> 일반 변수 할당<br>

👉 동적 바인딩 : 실행 시에 메모리를 할당한다.<br>
-> 변수 동적 할당<br>
<br>
<br>

**함수 바인딩 측면**<br>
👉 정적 바인딩<br>
1. 가상함수가 아닌 경우 -> 메모리 공간에 함수를 할당시키고 해당 함수의 주소로 바인딩한다.<br>
2. 가상함수인 경우 -> **건드리지 않는다.**<br>

👉 동적 바인딩<br>
1. 가상함수가 아닌 경우 -> 이미 할당되어있는 함수의 주소로 바인딩한다.<br>
2. 가상함수인 경우 <br>
-> **재정의된 함수가 있다면 해당 함수를 메모리에 올리고 주소를 바인딩한다.<br>
-> 재정의된 함수가 없다면 가상함수를 메모리에 올리고 주소를 바인딩한다.**<br>
<br>
<br>

이는 이론적인 부분에서는 의미가 있지만 실상에서는 큰 의미를 갖지 않는다.<br>
그러므로 **'이런 것이 있는데 분류를 굳이 하자면 이렇더라'** 정도로 생각하면 된다.<br>
<br>
<br>

## 🔔 참조링크
https://hellowoori.tistory.com/25 <br>
https://kyoun.tistory.com/33 <br>
