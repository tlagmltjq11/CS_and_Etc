## Garbage Collection
[ 1. C/C++에서의 메모리 관리 (Native Code)  ]
C/C++언어로 프로그래밍을 할 때 객체를 할당하기 위해 일일이 메모리 공간을 확보해야 하며, 객체를 할당한 후에는 힙을 가리키는 포인터의 사용이 끝나면 메모리를 해제해주어야 합니다. 프로그래밍을 짜다보면 메모리해제에 대해 깜빡하게되버리면 곧 누수가 되고, 사용자들에게 문제를 야기할 수 도 있답니다.
또한 해제한 메모리를 사용하려고한 경우 큰 문제가 발생하는 경우도 있습니다. 이렇듯 메모리를 직접 다루고 관리하는 일은 까다롭고도 위험하답니다.

또한 C/C++언어는 힙에 객체를 할당하기 위해 비싼 비용을 치루어야 합니다. C/C++기반의 프로그램을 실행하는 C-런타임은 객체를 담기 위한 메모리를 여러 개의 블록으로 나눈 뒤, 이 블록을 링크드 리스트로 묶어 관리하게됩니다. 객체를 메모리에 할당하기 위한 코드가 실행이 되면, C-런타임은 메모리 링크드 리스트를 순차적으로 탐색하면서 해당 객체를 담을 수 있을 만한 여유가 있는 메모리 블록을 찾습니다. 적절한 크기의 메모리 블록을 만나면, 프로그램은 이 메모리 블록을 쪼개서  객체를 할당하고 메모리 블록의 링크드 리스트를 재조정하게 됩니다.
단순히 메모리 공간을 할당하는 것이 아니라 공간을 탐색하고 분할하고 재조정하는 오버헤드가 필요하다는 것입니다.
<br>


[ 2. C#에서의 메모리 관리 (Managed Code) ]
C#에서는 C/C++에서 골치아프게 했던 이런 문제들로부터 자유로워졌습니다. CLR이 자동 메모리 관리 기능을 제공하기 때문이지요. 자동 메모리 관리 기능의 중심에는 가비지 컬렉션이 있습니다. 가비지 컬렉션은 프로그래머로 하여금 컴퓨터가 무한한 메모리를 갖고 있는 것처럼 간주하고 코드를 작성할 수 있게 해줍니다.

가비지 컬렉션에는 우리가 작성한 프로그램이 객체를 메모리에 할당해서 사용하고 있을 때, 객체 중 쓰레기인것과 쓰레기가 아닌 것을 완벽하게 분리해서 쓰레기들을 수거하는가비지 컬렉터라는 것이 존재합니다. 이름이 비슷하지요.
C/C++에서 저희가 직접 했던 일을 C#에서는 가비지 컬렉터가 알아서 해주니 정말 편하겠군요.. 하지만 가비지 컬렉터도 소프트웨어이기 때문에 CPU와 메모리같은 자원소모를 합니다. 저희가 코드작성에 필요한 자원을 가비지 컬렉터와 같이 사용해야 한다는 것이지요.

그래서 저흰 가비지 컬렉터가 큰 편의성을 주는 반면, 가비지 컬렉터가 최소한으로 자원을 사용할 수 있게 메모리 관리도 이루어져야 합니다. 그러기 위해서는 가비지 컬렉터의 메커니즘을 이해하고 있어야 한답니다.
