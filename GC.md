## Garbage Collection
[1. C/C++에서의 메모리 관리 (Native Code)]<br>
C/C++언어로 프로그래밍을 할 때 객체를 할당하기 위해 **일일이 메모리 공간을 확보해야 하며,<br>
객체를 할당한 후에는 힙을 가리키는 포인터의 사용이 끝나면 메모리를 해제해주어야 한다.**<br>
프로그래밍을 짜다보면 메모리해제에 대해 깜빡하게되버리면 곧 **누수**가 되고, 사용자들에게 문제를 야기할 수 도 있다.<br>
또한 해제한 메모리를 사용하려고한 경우 큰 문제가 발생하는 경우도 있다.<br>
이렇듯 **메모리를 직접 다루고 관리하는 일은 까다롭고도 위험하다.**<br>

또한 C/C++언어는 힙에 객체를 할당하기 위해 비싼 비용을 치루어야 한다.<br>
C/C++기반의 프로그램을 실행하는 C-런타임은 객체를 담기 위한 메모리를 여러 개의 블록으로 나눈 뒤,<br>
이 블록을 링크드 리스트로 묶어 관리하게된다. 객체를 메모리에 할당하기 위한 코드가 실행이 되면,<br>
C-런타임은 메모리 링크드 리스트를 순차적으로 탐색하면서 해당 객체를 담을 수 있을 만한 여유가 있는 메모리 블록을 찾는다.<br>
적절한 크기의 메모리 블록을 만나면, 프로그램은 이 메모리 블록을 쪼개서 객체를 할당하고 메모리 블록의 링크드 리스트를 재조정하게 된다.<br>
**단순히 메모리 공간을 할당하는 것이 아니라 공간을 탐색하고 분할하고 재조정하는 오버헤드가 필요하다는 것이다.**<br>
<br>
<br>

[2. C#에서의 메모리 관리 (Managed Code)]<br>
C#에서는 C/C++에서 골치아프게 했던 이런 문제들로부터 자유로워졌다.<br>
**CLR이 자동 메모리 관리 기능을 제공하기 때문이다.**<br>
자동 메모리 관리 기능의 중심에는 **가비지 컬렉션**이 있다.<br>
가비지 컬렉션은 프로그래머로 하여금 컴퓨터가 무한한 메모리를 갖고 있는 것처럼 간주하고 코드를 작성할 수 있게 해준다.<br>

가비지 컬렉션에는 우리가 작성한 프로그램이 객체를 메모리에 할당해서 사용하고 있을 때,<br>
**객체 중 쓰레기인것과 쓰레기가 아닌 것을 완벽하게 분리해서 쓰레기들을 수거하는가비지 컬렉터라는 것이 존재한다.**<br>
C/C++에서 직접 했던 일을 C#에서는 가비지 컬렉터가 알아서 해주니 정말 편한 것이다.<br>
**하지만 가비지 컬렉터도 소프트웨어이기 때문에 CPU와 메모리같은 자원소모를 한다.**<br>
우리가 코드작성에 필요한 자원을 가비지 컬렉터와 같이 사용해야 한다는 것이다.<br>

그래서 가비지 컬렉터가 큰 편의성을 주는 반면, **가비지 컬렉터가 최소한으로 자원을 사용할 수 있게 메모리 관리도 이루어져야 한다.**<br>
-> **GC의 호출을 최소화 해야 한다는 의미다.**<br>
그러기 위해서는 **가비지 컬렉터의 메커니즘을 이해하고 있어야 한다.**<br>
<br>
<br>

## GC의 가비지 수집 동작원리

* **c#에서 객체가 메모리에 할당되는 과정**
![gc1](https://user-images.githubusercontent.com/43705434/132116914-40a7ab53-3989-4bc2-9248-f9c17a79a3c0.PNG)<br>
<br>

C#으로 작성한 소스 코드를 컴파일해서 실행 파일을 만들고 이 실행 파일을 실행하면,<br>
CLR은 프로그램을 위한 일정 크기의 메모리를 확보한다.<br>
C-런타임처럼 메모리를 쪼개는 일은 하지 않는다.<br>
**그냥 메모리 공간을 통째로 확보해서 하나의 관리되는 힙을 마련한다.<br>
그리고 CLR은 이렇게 확보한 관리되는 힙 메모리의 첫번째 주소에 '다음 객체를 할당할 메모리의 포인터'를 위치시킨다.**<br>
<br>
<br>

![gc2](https://user-images.githubusercontent.com/43705434/132116915-1dacaa8d-eee3-4b76-a3c5-096341c05efe.PNG)<br>
<br>

```c#
Object A = new Object();
```
<br>

아무것도 할당되지 않은 메모리 공간에 첫 번째 객체를 할당해보겠다.<br>
CLR이 위 코드를 실행하면 '다음 객체를 할당할 메모리의 포인터'가 가리키고 있는 주소에<br>
A객체를 할당하고 포인터를 A객체가 차지하고 있는 공간 바로 뒤로 이동시킨다.<br>
<br>
<br>

```c#
Object B = new Object();
```

![gc3](https://user-images.githubusercontent.com/43705434/132116916-710bde4a-e33f-4e4c-a406-7c8b07490f8b.PNG)<br>
<br>

객체를 또 하나 만들어 보겠다.<br>
두 번째로 만드는 객체는 첫 번째 객체의 바로 뒤,<br>
'다음 객체를 할당할 메모리의 포인터'가 가리키고 있는 곳에 할당된다.<br>
-> **C, C++과 다르게 메모리 할당이 가능한 영역을 찾는 과정이 없기 때문에 속도가 훨씬 빠르다.**<br>

여기까지 객체가 메모리에 할당되는 과정을 알아보았다.<br>
그러면 할당된 객체들이 쓰레기인지 어떻게 판단하고 가비지 컬렉터가 수집해가는지 알아보자.<br>
<br>
<br>

* **가비지 컬렉터(Garbage Collector)의 원리**<br>

우리가 이미 알고 있는 것처럼 값 형식 객체는 스택에 할당되었다가 자신이 위치한 코드 블록이 끝나면 메모리로부터 사라진다.<br>
참조 형식 객체들만이 힙에 할당되어 코드 블록과 관계없이 계속 남아있을 것이다.<br>
<br>

```c#
if(true)
{
    object a = new object();
}
```
<br>

위와 같은 코드가 있을 때 a는 어디에 존재할까?<br>
a는 스택에 할당되고 a가 참조하고 있는 메모리는 힙 메모리의 주소를 참고하고 있다.<br>

![gc4](https://user-images.githubusercontent.com/43705434/132116917-4e0b7b1f-9e02-4cab-8608-f3a4c7fc94b9.PNG)<br>
<br>
<br>

만약 if문이 끝나면 a는 어떻게 될까?<br> 
a변수는 if문이 끝나자마자 스택에서 사라지고 더 이상 존재하지 않는 변수가 된다.<br>
<br>
<br>

![gc5](https://user-images.githubusercontent.com/43705434/132116918-f403898d-92c7-4201-84a3-2d8d3cbfefb5.PNG)<br>
<br>

이제 힙을 가리키고 있던 a의 객체는 사라지고 힙에 할당되었던 메모리는 어디에서도 접근할 수 없게된다.<br>
즉 쓰레기가 되버린것이다. **이제 이 쓰레기는 가비지 컬렉터가 수집을 할 대상이 되어버린것이다.**<br>
<br>

여기서 가비지 컬렉터가 어떻게 쓰레기인지 구분하는지 알아보자.<br>
먼저 a변수처럼 **힙에 할당된 메모리의 위치를 참조하고 있는 객체들을 '루트(Root)'라고 한다.**<br>
루트는 경우에 따라 스택에 할당될 수 도 있고, 힙에 할당될 수 도 있다.<br>
**.NET 애플리케이션이 실행되면 JIT컴파일러가 이 루트들을 목록으로 만들고,<br>
CLR은 이 루트 목록을 관리하며 상태를 갱신한다.<br>
이 루트가 중요한 이유는 가비지 컬렉터가 CLR이 관리하고 있던 루트목록을 참조해서 쓰레기 수집을 하기 때문이다.**<br>
<br>
<br>

![gc6](https://user-images.githubusercontent.com/43705434/132116902-90726225-9567-46f7-afd6-f3a92716c2dc.PNG)<br>
<br>

가비지 컬렉터가 루트 목록을 이용해서 쓰레기 객체를 정리하는 과정을 다시 정리하자면,<br>
첫번째로 작업을 시작하기 전에 가비지 컬렉터는 모든 객체가 쓰레기라고 가정한다.<br>
즉, 루트 목록내의 어떤 루트도 메모리를 가리키지 않는다고 가정하는 것이다.<br>
**그리고 나서 루트 목록을 순회하면서 각 루트가 참조하고 있는 힙 객체와의 관계 여부를 조사한다.<br>
루트가 참조하고 있는 힙의 객체가 또 다른 힙 객체를 참조하고 있다면 이 또한 해당 루트와 관계가 있는 것으로 판단한다.<br>
이 때 어떤 루트와도 관계가 없는 힙의 객체들은 쓰레기로 간주된다.**<br>
-> **C/C++과 다르게 Heap 전체를 검사할 필요가 없어 속도가 빠르며, 메모리 단편화가 발생하지 않는다.**<br>
<br>
<br>

![gc7](https://user-images.githubusercontent.com/43705434/132116903-1d16261e-cd21-4108-98ff-76989fad02ac.PNG)<br>
<br>

쓰레기 객체가 차지하고 있던 메모리는 이제 비어있는 공간으로 간주된다.<br>
루트 목록에 대한 조사가 끝나면, 가비지 컬렉터는 이제 힙을 순회하면서 쓰레기가 차지하고 있던<br>
'비어있는 공간'에 인접한 객체들을 이동시켜 차곡차곡 채워 넣는다.<br>
모든 객체의 이동이 끝나면 다음과 같이 깨끗한 상태의 메모리를 얻게된다.<br>
<br>
<br>

## 세대별 GC
이번에는 가비지 컬렉션의 성능을 높이기 위한 '세대별 가비지 컬렉션 알고리즘'에 대해 알아보겠다.<br>
CLR은 메모리를 구역별로 나누어 메모리에서 빨리 해제가 될 객체와 오래남아있을 객체들을 따로 담아 관리한다.<br>
**구체적으로 이야기 하면 CLR은 메모리를 0, 1, 2의 3개 세대로 나누고 0세대에는 빨리 사라질 것으로 예상되는 객체들을,<br>
2세대에는 오랫동안 남아있을 객체들을 위치시킨다. CLR이 객체의 수명을 예측하는 방법은,<br>
객체가 가비지 컬렉션을 겪은 횟수에 따라 나뉘는데, 횟수가 높을수록 메모리에서 오랫동안 남아있는 객체로 간주되고,<br>
횟수가 낮을 경우 빨리 사라질것이라고 간주된다.**<br>

따라서 0세대에는 가비지 컬렉션을 한 번도 겪지 않은 갓 생성된 객체들이 위치하게 되고<br>
2세대에는 최소 2회에서 수 차례동안 가비지 컬렉션을 겪고도 남은 객체들이 위치하게 된다.<br>
<br>

![세대별1](https://user-images.githubusercontent.com/43705434/132116904-67613af7-5b2e-4a6e-ac3c-9909ce83b58f.PNG)<br>
<br>

.NET 애플리케이션이 실행이 되면 CLR은 위와같이 비어있는 힙을 확보한다. 어떠한 객체도 할당되지 않은 상태이다.<br>
<br>

![세대별2](https://user-images.githubusercontent.com/43705434/132116905-a0210bce-09e6-412a-847c-1e84ec2e76f5.PNG)<br>
<br>

애플리케이션이 진행이 되면 차츰차츰 객체들이 힙에 할당이 된다.<br>
**할당된 객체들의 총 크기가 0세대 가비지 컬렉션 임계치에 도달하면 가비지 컬렉터는 0세대에 대해 가비지 컬렉션을 수행을 한다.**<br>
<br>

![세대별3](https://user-images.githubusercontent.com/43705434/132116907-f72a6e55-e723-4041-b216-95a7727f3954.PNG)<br>
<br>

그리고 나서 살아남은 객체들은 1세대로 옮겨지게 된다.<br>
이로써 0세대는 깨끗하게 비워지며, 2세대도 아직까지는 깨끗한 상태로 남아있게된다.<br>
<br>

![세대별4](https://user-images.githubusercontent.com/43705434/132116908-8d6427fa-c19a-4550-8eaa-29f711bba1ef.PNG)<br>
<br>

여전히 어플리케이션은 객체를 힙에 할당을 한다.<br>
새로 생성된 객체들은 당연히 0세대에 할당이 이루어진다.<br>
1세대에는 이전 가비지 컬렉션에서 살아남은 객체들이, 0세대에는 새로 생성된 객체들이 존재하게 된다.<br>
이제 0세대 객체의 용량이 0세대 가비지 컬렉션 임계치를 넘어서게되면,<br>
가비지 컬렉터는 다시 움직이기 시작한다. 가비지 컬렉터는 또 다시 0세대에 대해 가비지 컬렉션을 수행한다.<br>
<br>

![세대별5](https://user-images.githubusercontent.com/43705434/132116910-5511029e-f6e1-4117-8904-7d6c469d6b0a.PNG)<br>
<br>

0세대는 깨끗이 비워졌지만 또 다시 어플리케이션에 의해 새로운 객체들이 할당이 된다.<br>
이번에는 1세대의 임계치가 초과되었기 때문에 1세대에 대해 가비지 컬렉션을 수행한다.<br>
<br>

![세대별6](https://user-images.githubusercontent.com/43705434/132116911-dba725a0-4b7a-40ac-b349-ab06619d19ea.PNG)<br>
<br>

이 때 가비지 컬렉터는 하위 세대에 대해서도 가비지 컬렉션을 수행하기 때문에 0세대와 1세대에 대한 가비지 컬렉션이 수행된다.<br>
이 때 0세대에서 살아남은 객체는 1세대로, 1세대에서 살아남은 객체는 2세대로 옮겨진다.<br>
<br>

![세대별7](https://user-images.githubusercontent.com/43705434/132116912-a0b29110-1b5d-4cd6-ae07-cc1638f48e3e.PNG)<br>
<br>

그리고 계속 어플리케이션이 종료가 되기 전까지 객체가 생성이 되고 힙 메모리에 채워지게된다.<br>
그러면 또 다시 0세대에 새로운 객체들로 채워지기 시작한다.<br>
**각 세대의 메모리 임계치에 따라 가비지 컬렉션이 수행이 되고,**<br>
가비지 컬렉션이 반복됨에 따라 0세대의 객체들은 1세대로, 1세대의 객체들은 2세대로 계속 이동을 한다.<br> 

하지만 2세대로 옮겨간 객체들은 더 이상 다른 곳으로 옮겨가지 않는다.<br>
**2세대도 포화되어 2세대에 대한 가비지 컬렉션이 수행이 되면 0세대 1세대 모두 가비지 컬렉션을 수행한다.<br>
전체 가비지 컬렉션이라고 부르기도 한다.**<br>
<br>

![세대별8](https://user-images.githubusercontent.com/43705434/132116913-a0872b21-8a42-429b-80da-31b95b3dc11f.PNG)<br>
<br>

**하지만 0세대 가비지 컬렉션이 수행될 때, 1세대 2세대는 수행되지 않는다.**<br>
1세대때에도 마찬가지로 2세대는 수행되지 않는다.<br>
**이 처럼 힙의 각 세대는 2세대 < 1세대 < 0세대 순으로 가비지 컬렉션 빈도가 높다.<br>
이 떄문에 2세대 객체들은 오랫동안 살아남을 확률이 높고, 따라서 가비지 컬렉터도 상대적으로 덜 관심을 주는 편이다.**<br>


**만약, 2세대 임계치에 도달하게 될 경우 어떤일이 발생할까?<br>
CLR은 어플리케이션의 실행을 잠시 멈추고 전체 가비지 컬렉션을 수행함으로써 여유 메모리를 확보하려 한다.**<br>
CLR이 **Full GC**를 할 때는 0세대부터 2세대까지의 **전체 메모리를 거쳐 쓰레기를 수집하기 때문에<br>
어플리케이션이 차지하고 있던 메모리가 크면 클수록 Full GC 시간이 길어져<br>
어플리케이션이 정지되어있는 시간도 그만큼 늘어나게 된다.**<br>

이 문제는 가비지 컬렉션을 이해해야 하는 가장 중요한 이유중 하나이기도 하다.<br>
<br>
<br>

## GC가 발동되는 상황과 효율적인 코드 작성
즉 GC가 가비지를 수거하는 상황은 크게 3가지로 나눌 수 있다.<br>

1. 객체를 지속적으로 할당하여 세대 별 임계치를 넘어설 때
2. GC.Collect 메서드를 직접 호출 할 때 (디폴트는 Full GC이며 세대를 정할 수도 있다.)
3. 시스템의 메모리가 부족할 때

* 객체를 너무 많이 할당하지 말아라.
CLR의 객체 할당 속도가 빠르긴 하지만 너무 많은 수의 객체는 관리되는 힙의 각 세대에 대해<br>
임계치 초과를 초래하고, 이는 비번한 GC의 Call을 부르는 결과를 낳는다.<br>
고로 불필요한 객체의 잦은 생성을 피해야 한다.<br>

* 너무 큰 객체 할당을 피하자
CLR은 평범한 크기의 객체를 할당하는 힙과는 별도로 85KB 이상의 대형 객체를 할당하기 위한<br>
LOH(large obejct heap)을 따로 유지한다. 평소에 사용하는 힙은 LOH에 대비되는 개념으로<br>
SOH(small object heap)라고 부르기도 한다.<br>

큰 객체를 SOH에 할당한다면 0세대가 빠르게 차오르게 되므로 GC call을 보다 자주 초래하기에<br>
이런 이유 때문에 LOH를 별도로 운용하는 것이다. 하지만 이에도 약점이 존재하는데,<br>
LOH는 동작방식이 SOH와 다르다. SOH는 "다음 객체를 할당할 포인터" 가 위치한 메모리에<br>
바로 객체를 할당하지만, LOH는 객체의 크기를 계산한 뒤 그만한 여유 공간이 있는지 힙을 탐색 한 후<br>
객체를 할당하게 된다.<br>

또한 SOH는 GC 수행 후 해제된 메모리 공간에 인접 객체들을 끌어당겨 차곡차곡 정리하지만,<br>
LOH는 해제된 공간을 그대로 둔다. 큰 객체들이 존재하는 메모리인 만큼 재배치 할 메모리들이<br>
굉장히 크기 때문에 끌어당겨 정리하는 비용이 너무 크기 때문이다.<br>
이 공간은 나중에 다른 객체들에게 할당되겠지만, 메모리를 0바이트도 낭비 없이 사용하는 SOH와 달리<br>
큰 공간을 군데군데 낭비하게 된다. 결국 LOH는 할당 시의 성능뿐만 아니라 메모리 공간 효율도<br>
SOH에 비해 크게 떨어진다. 이러한 LOH는 C-Runtime과 비슷하게 동작하는 것이고 문제점도 비슷하다.<br>
-> **사실 위에서 설명했듯이 성능 저하를 피하기 위해서 메모리 재정렬을 하지 않는 것이지만<br>
-> 그 결과로 메모리 단편화가 일어날 수 있다는 것이다.**<br>
-> 최악의 경우 메모리 할당에 실패하는 경우가 발생한다.<br>

또한 CLR이 LOH를 2세대 힙으로 간주하기 때문에, LOH에 있는 가비지 객체가 수거되려면<br>
Full GC를 수행해야만 하는 상황이 초래된다.<br>
그렇기 때문에 너무 큰 객체를 사용하는 것은 성능에 큰 악영향을 미칠 수 있게 된다.<br>

* 너무 복잡한 참조 관계는 만들지 말자
```c#
class A
{
    public C c;
}

class B
{
    public A a;
}

class C
{
    public A a;
    public B[] b;
}

class D
{
    public A a;
    public B b;
    public C c;
}
```
<br>

위처럼 참조 관계가 많은 객체는 GC 수행 후에 살아남았을 때 문제를 일으킨다.<br>
**GC는 호출 이후 살아남은 객체의 세대를 옮기기 위해 메모리 복사를 수행하는데,**<br>
이 때 참조 관계가 복잡한 객체의 경우에는 단순히 메모리 복사를 하는데서 끝나지 않는다.<br>
객체를 구성하고 있는 각 필드 객체간의 참조 관계를 일일이 조사해서 참조하고 있는<br>
메모리 주소를 전부 수정한다. 클래스 구조를 간단하게 만들었다면 메모리 복사만으로<br>
끝났을 일을 탐색과 수정까지 끌어들이게 되는 것이다.<br>

문제는 또있다. D클래스를 예로 들어보자.<br>
D클래스 자체는 생성된지 오래되어 2세대에 존재하는데,<br>
A형식의 필드 a를 새로 생성한 객체로 업데이트 되었다고 가정해보자.<br>
이 경우 D의 인스턴스는 2세대에 살고 있고 a필드가 참조하고 있는 메모리는 0세대에 위치한다.<br>
이 때 루트를 갖고있지 않은 a는 0세대 GC에 의해 수거될 위험에 노출된다.<br>
이 때 Write Barrier(쓰기 장벽)이라는 장치를 통해 GC로 하여금 a필드가 루트를 갖고있는 것으로<br>
간주하게 해서 수거되는 것을 모면하게 해준다.<br>
하지만 Write Barrier을 생성하는 데 드는 오버헤드가 크기 때문에<br>
참조 관계를 최소한으로 만드는 것이 필요하다.<br>

* 루트를 너무 많이 만들지 말자
GC는 루트 목록을 돌면서 쓰레기를 찾아낸다.<br>
루트 목록이 작아진다면 그만큼 GC가 검사를 수행하는 횟수가 줄어드므로 더 빨리<br>
수행을 끝낼 수 있다. 따라서 루트를 가급적 많이 만들지 않는 것이 성능에 유리하다.<br>
이것은 필요 이상으로 객체를 만들지 말라는 지침만큼이나 기본적인 지침이다.<br>
<br>
<br>

## Unmanaged Resource
위에서 설명했듯이 대부분의 리소스들은 GC에 의해 자동적으로 수거가 된다.<br>
하지만 GC에 의해 관리되지 않는 리소스도 존재하기 때문에<br>
해당 리소스들의 자원을 해제하기 위해 Using - IDisposable을 사용하는 것이 좋다.<br>
-> 소멸자와 같은 finalizer를 사용할 수도 있지만 해당 방법은 단점이 많기 때문에<br>
-> 이보단 IDisposable을 이용해 unmanaged 리소스가 빠르게 해제될 수 있도록 구현하는 것이 좋다.<br>
다음 파일을 참고해서 복기하도록 하자.<br>
<br>
<br>

## GC 알고리즘 종류


과거에 유니티는 가난해서 최신버전의 GC를 적용할 수 없어 구식 GC를 사용하고 있었다고 한다.<br>
고로 성능면에서 뒤쳐질 수 밖에 없었는데, 자마린이 MS에 인수되면서 Mono가 오픈소스로 풀려<br>
최신 버전을 적용할 수 있게 되었다고 한다.<br>
<br>
<br>

## 참조링크
http://joyeeeeeee.blogspot.com/2018/01/c-60-garbagecollectorgarbagecollection.html <br>
https://nomad-programmer.tistory.com/235 <br>
https://huiyu.tistory.com/entry/C-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%ED%84%B0Garbage-Collector-%EA%B8%B0%EC%B4%88-finalizer-%EC%82%AC%EC%9A%A9 (Unmanaged Resource) <br>
