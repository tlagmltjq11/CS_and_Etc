## Memory Structure
우리는 C언어, C++, Java 등의 언어들을 이용하여 코딩을 하고 실행파일로 만든다.<br>
예를들어 C언어로 작성하여 빌드하고 만든 실행파일인 .exe 파일처럼 말이다.<br>
이러한 실행파일을 실행시키면 메모리에 로드되면서 코드에서 작성한 동작에 따라 메모리에 데이터들을 쓰고 읽는다.<br>

![프로세스실행과정](https://user-images.githubusercontent.com/43705434/132089150-c3c4aae3-3df6-4695-b1ba-49e343a269e8.PNG)<br>
<br>

좀 더 구체적으로 말하자면, 우선 실행파일을 만들어 **실행파일로 디스크에 저장**할것이다.<br>
그리고 사용자가 실행파일을 더블클릭(실행) 할 것이다. 이는 **운영체제에 실행파일을 실행하도록 요청**하는 것이다.<br>
그러면 운영체제는 프로그램의 정보들을 읽고 **메인 메모리에 공간을 할당**해준다.<br>
그리고 프로그램의 코드(변수, 함수 등)들을 메모리에 읽고 쓰면서 **동작**을 하게 되는 것이다.<br>
-> **즉 OS가 프로세스 별로 메인 메모리에 공간을 할당해주고 해당 메모리 공간을 사용하여 프로세스가 동작한다는 것.**<br>
 
![메모리구조](https://user-images.githubusercontent.com/43705434/132089149-a65a4508-f826-4b38-aa18-e3ed36dd245d.PNG)<br>
<br>

그럼 메모리에 어떻게 올라가는지를 알아보기 전에 **메모리의 구조**를 대략적으로나마 보겠다.<br>
각 **언어마다 조금씩 차이가 있지만 전체적인 구조 자체는 위 사진과 같이 영역이 나뉜다.**<br>
일단, 각 영역별로 간단하게 설명하도록 하겠다.<br>

[Text]<br>
텍스트 영역은 아주 쉽게 말하면 실행하기 위한 코드가 저장되어있는 영역이다.<br>
흔히 코드 영역이라고도 하는데, 프로그램을 실행시키기 위해 구성되는 것들이 저장되는 영역이다.<br>
한마디로 **명령문들이 저장되는 곳**인데, 제어문, 함수, 상수들이 이 영역에 저장된다.<br> 
**CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 된다.**<br>
<br>
 
[Data]<br>
데이터 영역은 우리가 작성한 코드에서 **전역변수, 정적변수 등이 저장되는 공간이다.**<br>
이들의 특징을 보면 보통 메인(main)함수 전(프로그램 실행 전)에 선언되어<br>
**프로그램이 끝날 때 까지 메모리에 남아있는 변수들이라는 특징이 있다.**<br>

좀 더 구체적으로 말하자면 Data영역도 크게 두 가지로 나뉜다.<br>
**초기화 된 변수 영역과 초기화되지 않은 변수 영역으로 나뉜다.**<br>
그리고 그 중 초기화되지 않은 변수 영역은 **BSS(Block Started by Symbol)** 이라고도 한다.<br> 

-> **C#, java 같은 경우 static 변수만이 Data 영역에 저장될 것이다.**<br>
-> 전역변수의 개념이 없고 필드만 존재하기 때문<br>
-> 사실 c#에서는 정적 변수 == 전역 변수 라는 관점이 많다!<br>
<br>
 
[Heap]<br>
힙 영역은 쉽게 말해서 **'사용자에 의해 관리되는 영역'** 이다.<br>
흔히 동적으로 할당 할 변수들이 여기에 저장된다고 보면 된다.<br>
언어마다 조금씩 상이하니 일단은 **동적 할당 영역'** 이라고 알아두면 될 것 같다.<br>
그리고 Heap 영역은 대개 **'낮은 주소에서 높은 주소로 할당(적재)된다'**<br>
너무 많은 동적할당을 진행할 경우 **Heap Overflow** 오류가 발생할 수 있다.<br>
-> Reference Type<br>
-> 물론 주소를 갖고있는 변수는 stack에 저장되어 있을 것이다.<br>

![힙오버플로우](https://user-images.githubusercontent.com/43705434/132089153-92f85bfc-3016-4f72-a388-b9af571c06fa.PNG)<br>
<br>
<br>

[Stack]<br>
스택 영역은 **함수를 호출 할 때 지역변수, 매개변수들이 저장되는 공간이다.**<br>
-> 스택 영역에 저장되는 함수의 호출 정보를 **스택프레임** 이라 한다.<br>
그리고 함수가 종료되면 해당 함수에 할당된 변수들을 메모리에서 해제시킨다.<br>
함수를 '재귀' 호출 할 때, 재귀가 깊어져 **Stack Overflow** 를 경험해봤을 거다.<br>
이 이유가 재귀를 반복적으로 호출하면서 **Stack 메모리 영역에 해당 함수의 지역변수, 매개변수들이<br>
계속 할당되다가 OS에서 할당해준 Stack영역의 메모리 영역을 넘어버리면 발생하는 오류이다.**<br>
Stack영역은 Heap영역과 반대로 **높은주소에서 낮은주소로 메모리에 할당된다.**<br>
-> Value Type<br>

![스택오버플로우](https://user-images.githubusercontent.com/43705434/132089152-659c13c3-8121-4c69-a330-ce9b6d2f1d04.PNG)<br>
<br>
<br>

## C# Memory Structure
C#의 메모리 구조는 위와 조금 다를 수 있는데 아마 JVM과 비슷하지 않을까 생각한다.<br>
우선 C# 또한 닷넷 프레임워크에서 제공하는 CLR 가상머신위에서 동작하기 때문에<br>
메모리 관리 또한 CLR에서 제공한다. 메모리 영역은 크게 Methods Area, Heap Area<br>
Stack Area, PC Register.. 등으로 나뉜다.<br>
Heap, Stack은 위에서 설명한것과 동일하지만 **Method 영역은 좀 더 알아볼 필요가 있다.**<br>
Method 영역은 **Class, Interface, Methods, Field, Static 변수 등의 바이트 코드를 보관한다.**<br>
당연하게도 해당 영역에 로드되어있는 Class만 new를 통해 생성이 가능하다.<br>
JVM 참고 https://steady-coding.tistory.com/305 <br>
<br>

위에서 설명한 메모리 구조대로 생각할 수도 있다.<br>
**다만 다른점은 Data 영역에 static 변수만이 들어갈 것이라는 점.<br>
이유는 c#에서는 전역변수의 개념이 없기 때문이다.**<br>
-> **사실 c#에서의 정적변수는 흔히 알고있는 전역변수와 생명주기, 액세스 범위 등이 동일하기에<br>
-> 정적변수 == 전역변수 로 보는 관점도 많다.**<br>
https://stackoverflow.com/questions/12913949/the-difference-between-a-global-variable-and-a-field <br>
<br>
<br>

## Memory Address
그렇다면 낮은주소 높은주소란 뭘까?<br>
일단, 이를 설명하기 전에 메모리 주소에 대해 잠깐 보고 가겠다.<br>

게임이나 어떤 프로그램을 다운로드 할 때 한 번쯤은 반드시 들어봤을 단어가 있다.<br>
바로 '32bit 운영체제 용', '64bit 운영체제 용'<br>
또는 Windows 운영체제 사용자들 대다수가 한 번쯤을 봤을 x86(32비트) 또는 x64(64비트) 가 있다.<br>

이 둘의 차이점은 직관적으로 말하자면 **데이터 처리 단위**라고 보면 된다.<br>
그리고 32개의 비트가 있다는 것은 0000 0000 0000 0000 0000 0000 0000 0000 부터<br>
1111 1111 1111 1111 1111 1111 1111 1111 까지, 그러니까 2^32의 경우의 수를 갖고,<br>
64개의 비트가 있다는 것은 2^64의 경우의 수를 갖는다는 것이다.<br>

이 둘의 차이는 생각보다 엄청나게 크다.<br>
2^32 = 4,294,967,296 (약 43억)<br>
2^64 = 18,446,744,073,709,551,616 (약 1844경)<br>

64bit 운영체제가 데이터 처리 단위가 더 많다보니 당연히 CPU 처리도 고속화 되고, 새로운 명령어들도 만들 수 있다.<br>
그렇다보니 64bit 운영체제에서는 32bit프로그램을 돌릴 수가 있지만, 32bit에서는 64bit용 프로그램을 돌릴 수가 없는 것이다.<br>

그럼 왜 32bit와 64bit를 설명하느냐?<br>
이 것이 바로 메모리와도 연관이 있기 때문이다.<br>
메모리 한칸은 1byte의 크기를 갖고 있다.<br>
그리고 32bit 운영체제에서는 32개의 비트, 즉 4바이트 길이의 주소를 갖는다.<br>
쉽게 말하자면 집 평수는 1평이고, 이 집을 가리키는 주소는 32자리로 표현하는것이다.<br>

그리고 2^32까지의 경우의 수가 있으니, 4,294,967,296 개의 주소를 가리킬 수 있다는 의미이고,<br>
이는 1바이트 크기의 메모리가 4,294,967,296 개 까지 인식이 가능하다는 것,<br>
즉 메모리의 최대 크기는 4,294,967,296 byte = 4GB 이다.<br>
옛날 32bit 운영체제가 대다수인 시절 메모리를 4GB까지밖에 설치 할 수 없는 이유가 여기서 나오는 것이다.<br>

그럼 64bit 운영체제는 어떨까?<br>
64bit 는 8바이트이므로 하나의 주소가 8바이트 길이의 주소를 갖는다는 것을 알 수 있을 것이다.<br>
그리고 마찬가지로 2^64개. 즉, 18,446,744,073,709,551,616 개의 주소를 가리킬 수 있다는 의미고<br>
이는 18,446,744,073,709,551,616 byte = 16EB(엑사바이트) = 16384TB(테라바이트) 까지다.<br>
한 마디로 이론적으로는 램을 16EB까지 설치 할 수 있다는 것이다. (엑사바이트는 테라바이트의 1024배)<br>
(대부분 32GB 또는 64GB까지 지원하여 사용한다.)<br>

엄청난 차이라는 것을 볼 수 있을 것이다.<br>
하지만 이 주소를 **2진수로 표현하기에는 너무 길어** 우리는 보통 **편의상 16진수로 표현한다.**<br>
32bit에서는 0x00000000 ~ 0xFFFFFFFF<br>
64bit에서는 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF<br>
이렇게 말이다.<br>

두 메모리를 좀 더 구체적으로 보자면 이렇게 된다.<br>

![32비트64비트메모리](https://user-images.githubusercontent.com/43705434/132089151-58459acd-058e-463e-92c5-0112e0e80f5e.PNG)<br>
<br>

요즘은 어떨지 모르겠지만, 보통 C언어에서 포인터(pointer)에 대해 배울 때<br>
포인터는 메모리 공간 주소를 가리키는 변수이고, "모든 포인터는 모두 4byte의 동일한 크기를 갖는다."<br>
라고 배우지만 이는 사실 32bit 운영체제에 한정해서 사실인 것이다.<br>

위에서 배운 내용을 생각해보면 포인터는 '주소'를 가리키기 때문에 운영체제가 몇비트이냐에 따라 달라진다.<br>
32bit에서는 포인터의 크기가 4byte라면, 64bit에서는 주소의 길이가 8byte이기 때문에<br>
당연하게도 포인터의 크기 또한 8byte일 수밖에 없다.<br>

더군다나 요즘은 아주 오래된 컴퓨터가 아니면 64bit 운영체제이기 때문에<br>
'운영체제 비트에 따라 포인터의 크기가 달라진다' 라고 배우거나,<br>
'보통의 경우 포인터는 8byte의 크기를 갖는다'로 가르치는 것이 앞으로의 대세가 되지 않을까 한다.<br>
 
다시 복기하고 넘어가자면 메모리 한 칸의 크기는 1바이트다.<br>
64비트 운영체제는 메모리 한 칸의 주소를 64비트로 표현하며 이는 8바이트와 같은 의미이고,<br>
메모리 주소를 8바이트로 표현하기 때문에 포인터(주소를 가리키는 변수)의 크기 또한 8바이트이다.<br>
<br>
<br>

## 참조링크
https://st-lab.tistory.com/198 <br>
